
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    PROVE_ID, PROVE_ELF, COMPOSE_ID, COMPOSE_ELF, COMBINED_ID, COMBINED_ELF,
};
use host::{prove_method, compose_method, combined_method};//,perform_composite_prove};

use host::proto::verifiable_processing_service_server::{
    VerifiableProcessingService, VerifiableProcessingServiceServer,
};
use host::proto::{
    CompositionRequest, CompositionResponse, Proof, ProveRequest, ProveResponse, VerifyRequest,
    VerifyResponse, CombinedRequest,
};
use risc0_zkvm::{Receipt};
use tonic::{transport::Server, Request, Response, Status};


#[derive(Default)]
pub struct VerifiableProcessingServiceServerImplementation;

#[tonic::async_trait]
impl VerifiableProcessingService for VerifiableProcessingServiceServerImplementation {
    async fn prove(
        &self,
        request: Request<ProveRequest>,
    ) -> Result<Response<ProveResponse>, Status> {
        println!("Got a proving request");

        let request = request.into_inner();
        let receipt: Receipt = prove_method(
            request.method_payload,
            request.previous_proof,
            PROVE_ID,
        );
        let (result_json,_metadata_json):(String,String) = receipt.journal.decode().unwrap();
            let reply = ProveResponse {
                public_output: result_json,
                proof_response: Some(Proof {
                    image_id: PROVE_ID.to_vec(),
                    receipt: bincode::serialize(&receipt).unwrap(),
                })
            };
        return Ok(Response::new(reply))
    }

    async fn combined(
        &self,
        request: Request<CombinedRequest>,
    ) -> Result<Response<ProveResponse>, Status> {
        println!("Got a combined request");

        let request = request.into_inner();
        let receipt: Receipt = combined_method(
            &request.method_payload.to_string(),
        );
        let (result_json,_metadata_json):(String,String) = receipt.journal.decode().unwrap();
        let reply = ProveResponse {
            public_output: result_json,
            proof_response: Some(Proof {
                image_id: COMBINED_ID.to_vec(),
                receipt: bincode::serialize(&receipt).unwrap(),
            })
        };
        return Ok(Response::new(reply))
    }

    async fn compose(
        &self,
        request: Request<CompositionRequest>,
    ) -> Result<Response<CompositionResponse>, Status> {
        println!("Got a composition request");
        let request = request.into_inner();
        let proofs: Vec<Proof> = request
            .proof_chain;

        let mut prev = proofs[0].clone();
        let mut result: Receipt = bincode::deserialize(&proofs[0].receipt).unwrap();
        for current in &proofs[1..] {
            result = compose_method(&prev, current);
            prev = Proof{image_id : COMPOSE_ID.to_vec(), receipt: bincode::serialize(&result).unwrap()};
        }

        let reply = CompositionResponse {
            proof_response: Some(Proof {
                image_id: COMPOSE_ID.to_vec(),
                receipt: bincode::serialize(&result).unwrap(),
            }),
            proof_chain: vec![],
        };
        Ok(Response::new(reply))
    }

    async fn verify(
        &self,
        request: Request<VerifyRequest>,
    ) -> Result<Response<VerifyResponse>, Status> {
        println!("Got a verification request");
        let request = request.into_inner();
        let proof = request
            .proof
            .ok_or(Status::invalid_argument("Missing proof"))?;
        let image_id: [u32; 8] = proof
            .image_id
            .try_into()
            .expect("Failed to convert Vec<u32> to [u32; 8]");
        let receipt: Receipt = bincode::deserialize(&proof.receipt).unwrap();

        let verification_result = receipt.verify(image_id);
        let public_data = receipt.journal.decode().unwrap();

        let reply: VerifyResponse;
        match verification_result {
            Ok(_) => {
                reply = VerifyResponse {
                    is_valid_executed: true,
                    public_output: public_data,
                };
            }
            Err(err) => {
                reply = VerifyResponse {
                    is_valid_executed: false,
                    public_output: public_data,
                };
                println!("{:?}", err)
            }
        }
        Ok(Response::new(reply))
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("{:?}",PROVE_ID);

    let addr = "[::1]:50051".parse()?;
    let vpssi: VerifiableProcessingServiceServerImplementation =
        VerifiableProcessingServiceServerImplementation::default();

    println!("VerifiableProcessingService listening on {}", addr);

    Server::builder()
        //.max_frame_size( * 1024 * 1024-10) // Set max frame size to 1GB
        .max_frame_size(16 * 1024 * 1024-10) // Set max frame size to 1GB
        //.max_encoding_message_size(1024 * 1024 * 1024-10) // Set max message size to 1GB
        .add_service(VerifiableProcessingServiceServer::new(vpssi))
        .serve(addr)
        .await?;

    Ok(())
}
