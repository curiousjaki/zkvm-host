use qfilter::Filter;
use rules::conformance::{PoamInput, RuleInput};
use rules::event_filter::InsertEvent;
use rules::{CardinalityRule, PrecedenceRule, Rule};
use serde_json;
use std::any::Any;
use std::str::FromStr;
use operations::{OperationRequest,Operation};
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use anyhow::Error;
use methods::{
    PROVE_ID, PROVE_ELF, COMPOSE_ID, COMPOSE_ELF, VERIFY_ID, VERIFY_ELF, COMBINED_ID, COMBINED_ELF,
};
use host::{prove_method, compose_method, combined_method};//,perform_composite_prove};

use host::proto::verifiable_processing_service_server::{
    VerifiableProcessingService, VerifiableProcessingServiceServer,
};
use host::proto::{
    CompositionRequest, CompositionResponse, Proof, ProveRequest, ProveResponse, VerifyRequest,
    VerifyResponse, CombinedRequest,
};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};
use tonic::{transport::Server, Request, Response, Status};


#[derive(Default)]
pub struct VerifiableProcessingServiceServerImplementation;

#[tonic::async_trait]
impl VerifiableProcessingService for VerifiableProcessingServiceServerImplementation {
    async fn prove(
        &self,
        request: Request<ProveRequest>,
    ) -> Result<Response<ProveResponse>, Status> {
        println!("Got a proving request");

        let request = request.into_inner();

        let previous_proof: Option<Proof> = request
                    .poam_metadata
                    .ok_or(Status::invalid_argument("Missing poam metadata"))?
                    .previous_proof;

        if previous_proof.is_some() {
            let previous_receipt: Receipt = bincode::deserialize(&previous_proof.unwrap().receipt).unwrap();
            let (previous_result_json,previous_metadata_json):(String,String) = previous_receipt.journal.decode().unwrap();
            let pi: PoamInput = PoamInput {
                image_id: PROVE_ID,
                rule_input: RuleInput {
                    rules: None,
                    ordering_rules: None,
                },
                public_data: Some((previous_result_json,previous_metadata_json)),
            };
            let receipt: Receipt = prove_method(
                &request.method_payload,
                &pi,
                Some(previous_receipt),
            );
            println!("{:?}","with receipt verification");

            let (result_json,metadata_json):(String,String) = receipt.journal.decode().unwrap();
            let reply = ProveResponse {
                public_output: result_json,
                proof_response: Some(Proof {
                    image_id: PROVE_ID.to_vec(),
                    receipt: bincode::serialize(&receipt).unwrap(),
                }),
                proof_chain: vec![],
            };
            return Ok(Response::new(reply))
        } else{
            let pi: PoamInput = PoamInput {
                image_id: PROVE_ID,
                rule_input: RuleInput {
                    rules: None,
                    ordering_rules: None,
                },
                public_data: None,
            };
            let receipt: Receipt = prove_method(
                &request.method_payload,
                &pi,
                None,
            );
            println!("{:?}","no receipt verification");
            let (result_json,metadata_json):(String,String) = receipt.journal.decode().unwrap();
            let reply = ProveResponse {
                public_output: result_json,
                proof_response: Some(Proof {
                    image_id: PROVE_ID.to_vec(),
                    receipt: bincode::serialize(&receipt).unwrap(),
                }),
                proof_chain: vec![],
            };
            return Ok(Response::new(reply))
        }
       
    }
    async fn combined(
        &self,
        request: Request<CombinedRequest>,
    ) -> Result<Response<ProveResponse>, Status> {
        println!("Got a combined request");

        let request = request.into_inner();
        //println!("{:?}",&request.method_payload.to_string());
        let receipt: Receipt = combined_method(
            &request.method_payload.to_string(),
        );
        let (result_json,metadata_json):(String,String) = receipt.journal.decode().unwrap();
        let reply = ProveResponse {
            public_output: result_json,
            proof_response: Some(Proof {
                image_id: COMBINED_ID.to_vec(),
                receipt: bincode::serialize(&receipt).unwrap(),
            }),
            proof_chain: vec![],
        };
        return Ok(Response::new(reply))
    }

    async fn compose(
        &self,
        request: Request<CompositionRequest>,
    ) -> Result<Response<CompositionResponse>, Status> {
        println!("Got a composition request");
        let request = request.into_inner();
        let proofs: Vec<Proof> = request
            .proof_chain;

        let mut prev = proofs[0].clone();
        let mut result: Receipt = bincode::deserialize(&proofs[0].receipt).unwrap();
        for current in &proofs[1..] {
            result = compose_method(&prev, current);
            prev = Proof{image_id : COMPOSE_ID.to_vec(), receipt: bincode::serialize(&result).unwrap()};
        }
        //let composite_receipt = compose_method(&receipts[0], &receipts[1]);
            //.expect("Failed to prove composite receipt");
        println!("Receipt vector created");

        // TODO: Implement code for retrieving receipt journal here.

        let reply = CompositionResponse {
            proof_response: Some(Proof {
                image_id: COMPOSE_ID.to_vec(),
                receipt: bincode::serialize(&result).unwrap(),
            }),
            proof_chain: vec![],
        };
        Ok(Response::new(reply))
    }

    async fn verify(
        &self,
        request: Request<VerifyRequest>,
    ) -> Result<Response<VerifyResponse>, Status> {
        println!("Got a verification request");
        let request = request.into_inner();
        let proof = request
            .proof
            .ok_or(Status::invalid_argument("Missing proof"))?;
        let image_id: [u32; 8] = proof
            .image_id
            .try_into()
            .expect("Failed to convert Vec<u32> to [u32; 8]");
        let receipt: Receipt = bincode::deserialize(&proof.receipt).unwrap();
        //print_type_of(&req.receipt);
        //let receipt = Receipt::from(request.receipt.unwrap());
        let verification_result = receipt.verify(image_id);
        let public_data = receipt.journal.decode().unwrap();

        //println!("{:?}",receipt.journal.);
        let reply: VerifyResponse;
        match verification_result {
            Ok(_) => {
                reply = VerifyResponse {
                    is_valid_executed: true,
                    public_output: public_data,
                };
            }
            Err(err) => {
                reply = VerifyResponse {
                    is_valid_executed: false,
                    public_output: public_data,
                };
                println!("{:?}", err)
            }
        }
        Ok(Response::new(reply))
    }
}



fn main2() {
    //env_logger::init();
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    println!("Started the Program");
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();
    //let filter = qfilter::Filter::new(1000, 0.01).expect("Failed to create filter");
    //let rule1 = Rule::Cardinality(CardinalityRule{prior: [1,2,3,4,5,6,7,8],max: 1, min: 1});
    //let rule_set: RuleSet = RuleSet{rules: vec![rule1], qf: filter};
    let mut f = Filter::new(100, 0.01).expect("Failed to create filter");
    f.insert_event(PROVE_ID);
    let mut rules: Vec<Rule> = vec![Rule::Precedence(PrecedenceRule {
        //current: VERIFIABLE_PROCESSING_ID,
        preceeding: PROVE_ID,
    })];
    //let cm: ConformanceMetadata = ConformanceMetadata {
    //    previous_image_id: VERIFIABLE_PROCESSING_ID,
    //    current_image_id: VERIFIABLE_PROCESSING_ID,
    //    rules: rules,
    //    qf: f,
    //};
    let method_payload = serde_json::to_string(&OperationRequest{a: 1.0, b: 2.0, operation: Operation::Add }).unwrap();
    //let receipt1 = prove_method(&method_payload, &cm);
    //let receipt2 = prove_method(1.0, 2.0, Operation::Mul, rule_set.clone());
    //let receipt3 = prove_method(1.0, 2.0, Operation::Sub, rule_set.clone());
    //let receipt4 = prove_method(1.0, 2.0, Operation::Div, rule_set);

    //let receipts: Vec<Receipt> = vec![receipt1]; //, receipt2, receipt3, receipt4];//, receipt3, receipt4];
    println!("Receipt vector created");
    //let composite_receipt = perform_composite_prove(receipts, VERIFIABLE_PROCESSING_ID)
    //    .expect("Failed to prove composite receipt");
    // TODO: Implement code for retrieving receipt journal here.

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    //println!("Composite receipt created");
    //composite_receipt.verify(COMPOSITE_PROVING_ID).unwrap();

    //println!("{:?}", composite_receipt);
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let addr = "[::1]:50051".parse()?;
    let vpssi: VerifiableProcessingServiceServerImplementation =
        VerifiableProcessingServiceServerImplementation::default();

    println!("VerifiableProcessingService listening on {}", addr);

    Server::builder()
        //.max_frame_size( * 1024 * 1024-10) // Set max frame size to 1GB
        .max_frame_size(16 * 1024 * 1024-10) // Set max frame size to 1GB
        //.max_encoding_message_size(1024 * 1024 * 1024-10) // Set max message size to 1GB
        .add_service(VerifiableProcessingServiceServer::new(vpssi))
        .serve(addr)
        .await?;

    Ok(())
}
